√úbungen zu OOP
Beim vorherigen Kapitel "Java Grundlagen" hast du im Tutorial bereits ersten Kontakt zur Objektorientierten Programmierung gemacht (OOP = "Object Oriented Programming"). Nun wird es Zeit dieses Wissen in der Praxis auf die Probe zu stellen mit einigen kleinen √úbungsaufgaben die dich zum "Denken in OOP" anregen sollen.

Aufgabe 1: Einfache Klassen im Autohaus
Ein Autohaus hat einen Namen und einen Besitzer, sowie eine Adresse. H√§ufig steht das Autohaus auch nur f√ºr eine bestimmte Automarke.
Ein Autohaus verkauft...Autos! Das bedeutet, dass ein Autohaus auch eine bestimmte Menge an Autos auf seiner Verkaufsfl√§che anbietet. Ein Auto kennzeichnet sich durch einen Hersteller, seine Antriebsart, seine Motorleistung, seine Farbe und seine Sonderausstattung.
Implementiere die Klassen "Autohaus" und "Auto". Erstelle in deiner main-Methode ein Autohaus mit mehreren Autos und gebe das erstellte Autohaus in Textform auf der Konsole sch√∂n formattiert aus.

Aufgabe 2: Vererbung mit Flugzeugen
Im Rahmen einer Softwareentwicklung f√ºr die einheitliche Verwaltung von Flugzeugen wurde die Klasse Flugzeug entwickelt. Die Klasse Flugzeug ist auszugsweise angegeben:

abstract class Flugzeug {

    /**
     * Name des Herstellername
     */
    private String hersteller;

    /**
     * Maximale Geschwindigkeit
     */
    private int maxSpeed;

    private String luftfahrzeugkennzeichen;

    private int anzahlFluegelpaare = 1;

    public Flugzeug(String hersteller, int maxSpeed, int anzahlFluegelpaare) {
        this.hersteller = hersteller;
        this.maxSpeed = maxSpeed;
        this.anzahlFluegelpaare = anzahlFluegelpaare;
    }

    public String getLuftfahrzeugkennzeichen() {
        return luftfahrzeugkennzeichen;
    }

    protected void setLuftfahrzeugkennzeichen(String luftfahrzeugkennzeichen) {
        this.luftfahrzeugkennzeichen = luftfahrzeugkennzeichen;
    }

    public int getMaxSpeed() {
        return maxSpeed;
    }

    abstract public boolean getLooping();

    // weitere Methoden...
}
Schreibe ausgehend von dieser Klasse eine Klasse Verkehrsflugzeug sowie eine Klasse Doppeldecker. Diese sollen folgende Spezifikation erf√ºllen:

Klasse Verkehrsflugzeug

Ein Verkehrsflugzeug ist ein Flugzeug, das genau ein Fl√ºgelpaar sowie eine zus√§tzliche Variable f√ºr die Anzahl der Passagiere hat.
Ein Verkehrsflugzeug fliegt keine Loopings. Stelle deshalb sicher, dass die Methode getLooping immer false zur√ºckgibt, auch in allf√§lligen Unterklassen von Verkehrsflugzeug.
Schreibe einen Konstruktor, mit dem ein Verkehrsflugzeug-Objekt erzeugt werden kann. Dazu m√ºssen der Hersteller (String), die maximale Geschwindigkeit (int), das Luftfahrzeugkennzeichen (String) und die Anzahl Passagiere (int) angegeben werden.
Die Klasse Verkehrsflugzeug hat die Methoden getAnzahlPassagiere und setAnzahlPassagiere zum Abfragen und Setzen der Anzahl der Passagiere.


Klasse Doppeldecker

Ein Doppeldecker ist ein Flugzeug, das genau zwei Fl√ºgelpaare hat.
Weiter ist ein Doppeldecker akrobatiktauglich, d.h. man kann damit Loopings fliegen. F√ºr einen Looping muss der Doppeldecker eine Mindestgeschwindigkeit von 320 km/h erreichen. Definiere daf√ºr eine Konstante LOOPINGSPEED. Die Methode getLooping soll true zur√ºckgeben, falls die zul√§ssige max. Geschwindigkeit (maxSpeed) gr√∂sser LOOPINGSPEED ist.
Die Klasse Doppeldecker hat eine Variable offenesCockpit vom Typ boolean. Sie gibt an, ob der Doppeldecker ein offenes oder geschlossenes Cockpit hat. Nachdem offenesCockpit gesetzt worden ist, darf sie nicht mehr ver√§ndert werden.
Schreibe eine Methode isOffenesCockpit, die den Wert von offenesCockpit zur√ºckgibt.
Schreibe zwei Konstruktoren, mit denen ein Doppeldecker-Objekt initialisiert werden kann.

Der 1. Konstruktor hat folgende Parameter: Hersteller (String), maximale Geschwindigkeit (int), das Luftfahrzeugkennzeichen (String) und einen boolean offenesCockpit, der angibt, ob der Doppeldecker ein offenes oder geschlossenes Cockpit hat
Der 2. Konstruktor hat folgende Parameter: Hersteller (String), maximale Geschwindigkeit (int), das Luftfahrzeugkennzeichen (String). Der Defaultwert f√ºr offenesCockpit bei einem Doppeldecker ist true.


Die Klasse Doppeldecker soll nicht erweiterbar sein.


Aufgabe 3: Abstrakte Klassen / Interfaces
Ein Pizzastore produziert verschiedene Pizzen: Margherita, Napolitana, QuattroStagione etc. Alle Pizzen haben folgende Attribute: zutaten[] und preis. Zudem musst du folgende Methoden implementieren: getZutaten und getPreis.
Die Pizza Margherita ist in verschiedenen Gr√∂ssen (klein, mittel, gross) erh√§ltlich; sie hat daher ein zus√§tzliches Attribut gr√∂sse und eine zus√§tzliche Methode getGr√∂sse. Der Preis ist von der Gr√∂sse abh√§ngig (proportional zur Gr√∂sse).

3.1
Verwende f√ºr diese Aufgabe ein Interface (keine Basisklasse):

Schreibe die Klassen PizzaNapolitana und PizzaMargherita.
Schreibe eine Mini-Buchhaltung f√ºr Pizzas. Die Pizzas werden in einen Array eingetragen. F√ºlle das Array mit je einer PizzaNapolitana und PizzaMargherita.
Schreibe geeigneten Code, der den Preis der beiden im Array enthaltenen Pizzas errechnet.


3.2
Schreibe f√ºr die obigen Pizzas eine Basisklasse Pizza (nur diese).

Die Klasse Pizza kann nicht instanziert werden.
√úberlege, welche Methoden bereits in der Basisklasse implementiert werden k√∂nnen und welche erst in den Subklassen implementiert werden m√ºssen.


Aufgabe 4: Polymorphismus
Du schreibst im Folgenden eine Ticketkontrolle. Konzentriere dich auf die Aufgabenstellung und nicht auf irgendwelche Eigenheiten in deinem Lieblingsverkehrsverbund üòú.
So kannst du davon ausgehen, dass Fahrg√§ste immer kontrolliert werden (keine Selbstkontrolle). Einzeltickets und Mehrfahrtenkarten sind immer nur in einer Zone g√ºltig. Generalabos gelten im ganzen Netz.
Vervollst√§ndige nun folgendes Ger√ºst einer Ticketkontrolle in der Klasse "Kontrolleur" im folgenden Projekt:
"Polymorphismus.7z" (Entpacke den Ordner und √∂ffne das Projekt in deiner IDE.)
Der Kontrolleur hat zur Verf√ºgung:

Die Namen aller Fahrg√§ste
Ihre Tickets. Dabei gilt: tickets[i] ist das Ticket des Fahrgasts mit Namen namen[i]
Die aktuelle Zone, in der die Kontrolle stattfindet
Das heutige Datum

Der Kontrolleur muss alle Tickets entwerten, und die Anzahl der Schwarzfahrer z√§hlen. Ein entwertetes Ticket ist nie g√ºltig. Ansonsten ist die G√ºltigkeit vom Typ des Tickets abh√§ngig. √úberlege dir sorgf√§ltig das richtige Kriterium.
Hinweis: Das Datum ist als String abgelegt in der Form ‚ÄûJJJJMMTT‚Äú. Solche Daten kann man lexikographisch miteinander vergleichen (d.h. gem√§ss Ihrer ‚Äûalphabetischen‚Äú Reihenfolge. Du kannst die String-Methode compareToverwenden).
Wenn du alles richtig implementiert hast und die main-Methode ausf√ºhrt, sollte am Ende folgender Text auf der Konsole erscheinen:

Es gab insgesamt 2 Personen ohne g√ºltigen Fahrschein.
